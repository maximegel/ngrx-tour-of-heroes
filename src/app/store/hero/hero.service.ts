import { Injectable } from '@angular/core';
import kebabCase from 'lodash/kebabCase';
import uniqueId from 'lodash/uniqueId';
import { BehaviorSubject, EMPTY, Observable, of, throwError } from 'rxjs';
import { delay, map, mergeMap } from 'rxjs/operators';
import { CreateHero, DeleteHero, EditHero, LoadOneHero } from './hero.actions';
import { Hero, HeroAlterEgo, HeroPeek } from './hero.entity';
import { HEROES } from './hero.mocks';

@Injectable({ providedIn: 'root' })
export class HeroService {
  private heroes$ = new BehaviorSubject<Map<string | number, Hero>>(HEROES);

  create(payload: CreateHero): Observable<Hero> {
    const id = uniqueId();
    return this.heroes$.pipe(
      delay(1000),
      map(heroes => {
        const hero = {
          ...payload,
          id,
          avatar: '',
          ...this.autoGeneratedFields(payload),
        };
        this.heroes$.next(heroes.set(id, hero));
        return hero;
      }),
    );
  }

  delete(payload: DeleteHero): Observable<void> {
    return EMPTY.pipe(delay(1000));
  }

  edit(payload: EditHero): Observable<Hero> {
    return this.heroes$.pipe(
      delay(1000),
      map(heroes => {
        const existing = heroes.get(payload.id);
        if (!existing) throw new Error('Hero not found.');
        const hero = {
          ...existing,
          ...payload,
          ...this.autoGeneratedFields(payload),
        };
        heroes.set(payload.id, hero);
        return hero;
      }),
    );
  }

  find(payload: LoadOneHero): Observable<Hero> {
    return this.heroes$.pipe(
      delay(1000),
      map(heroes => Array.from(heroes.values())),
      map(heroes => heroes.find(hero => hero.id === payload.id || hero.slug === payload.slug)),
      mergeMap(found => (!!found ? of(found) : throwError(new Error('Hero not found.')))),
    );
  }

  list(): Observable<HeroPeek[]> {
    return this.heroes$.pipe(
      delay(1000),
      map(heroes => Array.from(heroes.values())),
    );
  }

  private autoGeneratedFields(
    hero: Pick<EditHero | CreateHero, 'name' | 'alterEgo'>,
  ): Pick<Hero, 'slug'> & { alterEgo: HeroAlterEgo | undefined } {
    return {
      slug: kebabCase(hero.name),
      alterEgo: hero.alterEgo
        ? { ...hero.alterEgo, displayName: `${hero.alterEgo.firstName} ${hero.alterEgo.lastName}` }
        : undefined,
    };
  }
}
